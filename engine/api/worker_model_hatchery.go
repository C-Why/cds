package api

import (
	"context"
	"net/http"

	"github.com/ovh/cds/engine/api/cache"
	"github.com/ovh/cds/engine/api/workermodel"
	"github.com/ovh/cds/engine/service"
	"github.com/ovh/cds/sdk"
)

func (api *API) bookWorkerModelHandler() service.Handler {
	return func(ctx context.Context, w http.ResponseWriter, r *http.Request) error {
		// this handler should only answer to an hatchery
		s, ok := api.isHatchery(ctx)
		if !ok {
			return sdk.WithStack(sdk.ErrForbidden)
		}

		// TODO permModelID middleware
		workerModelID, errr := requestVarInt(r, "permModelID")
		if errr != nil {
			return sdk.WrapError(errr, "invalid permModelID")
		}

		if err := workermodel.BookForRegister(api.Cache, workerModelID, s.ID); err != nil {
			return sdk.WithStack(err)
		}

		return nil
	}
}

func (api *API) spawnErrorWorkerModelHandler() service.Handler {
	return func(ctx context.Context, w http.ResponseWriter, r *http.Request) error {
		var spawnErrorForm sdk.SpawnErrorForm
		if err := service.UnmarshalBody(r, &spawnErrorForm); err != nil {
			return sdk.WrapError(err, "Unable to parse spawn error form")
		}

		workerModelID, err := requestVarInt(r, "permModelID")
		if err != nil {
			return err
		}

		tx, err := api.mustDB().Begin()
		if err != nil {
			return sdk.WithStack(err)
		}
		defer tx.Rollback() // nolint

		model, err := workermodel.LoadByID(tx, workerModelID)
		if err != nil {
			return err
		}

		if spawnErrorForm.Error == "" && len(spawnErrorForm.Logs) == 0 {
			return nil
		}

		if err := workermodel.UpdateSpawnErrorWorkerModel(tx, model.ID, spawnErrorForm); err != nil {
			return sdk.WrapError(err, "cannot update spawn error on worker model")
		}

		if err := tx.Commit(); err != nil {
			return err
		}

		key := cache.Key("api:workermodels:*")
		api.Cache.DeleteAll(key)
		workermodel.UnbookForRegister(api.Cache, workerModelID)

		return service.WriteJSON(w, nil, http.StatusOK)
	}
}

func (api *API) getWorkerModelsEnabledHandler() service.Handler {
	return func(ctx context.Context, w http.ResponseWriter, r *http.Request) error {
		// this handler should only answer to an hatchery
		_, ok := api.isHatchery(ctx)
		if !ok {
			return sdk.WithStack(sdk.ErrForbidden)
		}

		// for an hatchery the token was generated by a admin for all consumer's groups.
		models, err := workermodel.LoadAllUsableWithClearPasswordByGroupIDs(api.mustDB(),
			getAPIConsumer(ctx).GetGroupIDs())
		if err != nil {
			return err
		}

		return service.WriteJSON(w, models, http.StatusOK)
	}
}
