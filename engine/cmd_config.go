package main

import (
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/spf13/cobra"
	toml "github.com/yesnault/go-toml"

	"github.com/ovh/cds/engine/api"
	"github.com/ovh/cds/engine/api/authentication"
	"github.com/ovh/cds/engine/api/authentication/builtin"
	"github.com/ovh/cds/engine/api/services"
	"github.com/ovh/cds/engine/hatchery/kubernetes"
	"github.com/ovh/cds/engine/hatchery/local"
	"github.com/ovh/cds/engine/hatchery/marathon"
	"github.com/ovh/cds/engine/hatchery/openstack"
	"github.com/ovh/cds/engine/hatchery/swarm"
	"github.com/ovh/cds/engine/hatchery/vsphere"
	"github.com/ovh/cds/engine/hooks"
	"github.com/ovh/cds/engine/vcs"
	"github.com/ovh/cds/sdk"
	"github.com/ovh/cds/sdk/jws"
	"github.com/ovh/cds/sdk/namesgenerator"
)

func init() {
	configCmd.AddCommand(configNewCmd)
	configCmd.AddCommand(configCheckCmd)

	configNewCmd.Flags().BoolVar(&flagConfigNewAsEnv, "env", false, "Print configuration as environment variable")
}

var (
	flagConfigNewAsEnv bool
)

var configCmd = &cobra.Command{
	Use:   "config",
	Short: "Manage CDS Configuration",
}

var configNewCmd = &cobra.Command{
	Use:   "new",
	Short: "CDS configuration file assistant",
	Long: `
Generate the whole configuration file
	$ engine config new > conf.toml

you can compose your file configuration
this will generate a file configuration containing
api and hatchery:local µService
	$ engine config new api hatchery:local

For advanced usage, Debug and Tracing section can be generated as:
	$ engine config new debug tracing [µService(s)...]

All options
	$ engine config new [debug] [tracing] [api] [hatchery:local] [hatchery:marathon] [hatchery:openstack] [hatchery:swarm] [hatchery:vsphere] [elasticsearch] [hooks] [vcs] [repositories] [migrate]

`,

	Run: func(cmd *cobra.Command, args []string) {
		conf := configBootstrap(args)

		apiPrivateKey, err := jws.NewRandomRSAKey()
		if err != nil {
			sdk.Exit("%v", err)
		}
		apiPrivateKeyPEM, err := jws.ExportPrivateKey(apiPrivateKey)
		if err != nil {
			sdk.Exit("%v", err)
		}
		var startupCfg api.StartupConfig

		if err := authentication.Init("cds-api", apiPrivateKeyPEM); err != nil {
			sdk.Exit("%v", err)
		}

		if conf.API != nil {
			conf.API.Auth.RSAPrivateKey = string(apiPrivateKeyPEM)
			conf.API.Secrets.Key = sdk.RandomString(32)
			conf.API.Services = append(conf.API.Services, api.ServiceConfiguration{
				Name:       "sample-service",
				URL:        "https://ovh.github.io",
				Port:       "443",
				Path:       "/cds",
				HealthPath: "/cds",
				HealthPort: "443",
				HealthURL:  "https://ovh.github.io",
				Type:       "doc",
			})
		}

		if h := conf.Hatchery; h != nil {
			if h.Local != nil {
				var cfg = api.StartupConfigService{
					ID:          sdk.UUID(),
					Name:        "hatchery:local",
					Description: "Autogenerated configuration for local hatchery",
					ServiceType: services.TypeHatchery,
				}

				var c = sdk.AuthConsumer{
					ID:          cfg.ID,
					Name:        cfg.Name,
					Description: cfg.Description,

					Type:     sdk.ConsumerBuiltin,
					Data:     map[string]string{},
					GroupIDs: []int64{},
					Scopes:   []sdk.AuthConsumerScope{sdk.AuthConsumerScopeHatchery, sdk.AuthConsumerScopeRunExecution, sdk.AuthConsumerScopeService},
				}

				h.Local.API.Token, err = builtin.NewSigninConsumerToken(&c)
				if err != nil {
					sdk.Exit("%v", err)
				}
				startupCfg.Consumers = append(startupCfg.Consumers, cfg)

				privateKey, _ := jws.NewRandomRSAKey()
				privateKeyPEM, _ := jws.ExportPrivateKey(privateKey)
				h.Local.RSAPrivateKey = string(privateKeyPEM)
				h.Local.Name = "cds-hatchery-local-" + namesgenerator.GetRandomNameCDS(0)
			}
			if h.Openstack != nil {
				var cfg = api.StartupConfigService{
					ID:          sdk.UUID(),
					Name:        "hatchery:openstack",
					Description: "Autogenerated configuration for openstack hatchery",
					ServiceType: services.TypeHatchery,
				}

				var c = sdk.AuthConsumer{
					ID:          cfg.ID,
					Name:        cfg.Name,
					Description: cfg.Description,
					Type:        sdk.ConsumerBuiltin,
					Data:        map[string]string{},
					GroupIDs:    []int64{},
					Scopes:      []sdk.AuthConsumerScope{sdk.AuthConsumerScopeHatchery, sdk.AuthConsumerScopeRunExecution, sdk.AuthConsumerScopeService},
				}

				h.Openstack.API.Token, err = builtin.NewSigninConsumerToken(&c)
				if err != nil {
					sdk.Exit("%v", err)
				}

				startupCfg.Consumers = append(startupCfg.Consumers, cfg)
				privateKey, _ := jws.NewRandomRSAKey()
				privateKeyPEM, _ := jws.ExportPrivateKey(privateKey)
				h.Openstack.RSAPrivateKey = string(privateKeyPEM)
				h.Openstack.Name = "cds-hatchery-openstack-" + namesgenerator.GetRandomNameCDS(0)
			}
			if h.VSphere != nil {
				var cfg = api.StartupConfigService{
					ID:          sdk.UUID(),
					Name:        "hatchery:vsphere",
					Description: "Autogenerated configuration for vsphere hatchery",
					ServiceType: services.TypeHatchery,
				}

				var c = sdk.AuthConsumer{
					ID:          cfg.ID,
					Name:        cfg.Name,
					Description: cfg.Description,

					Type:     sdk.ConsumerBuiltin,
					Data:     map[string]string{},
					GroupIDs: []int64{},
					Scopes:   []sdk.AuthConsumerScope{sdk.AuthConsumerScopeHatchery, sdk.AuthConsumerScopeRunExecution, sdk.AuthConsumerScopeService},
				}

				h.VSphere.API.Token, err = builtin.NewSigninConsumerToken(&c)
				if err != nil {
					sdk.Exit("%v", err)
				}

				startupCfg.Consumers = append(startupCfg.Consumers, cfg)
				privateKey, _ := jws.NewRandomRSAKey()
				privateKeyPEM, _ := jws.ExportPrivateKey(privateKey)
				h.VSphere.RSAPrivateKey = string(privateKeyPEM)
				h.VSphere.Name = "cds-hatchery-vsphere-" + namesgenerator.GetRandomNameCDS(0)
			}
			if h.Swarm != nil {
				var cfg = api.StartupConfigService{
					ID:          sdk.UUID(),
					Name:        "hatchery:swarm",
					Description: "Autogenerated configuration for swarm hatchery",
					ServiceType: services.TypeHatchery,
				}

				var c = sdk.AuthConsumer{
					ID:          cfg.ID,
					Name:        cfg.Name,
					Description: cfg.Description,

					Type:     sdk.ConsumerBuiltin,
					Data:     map[string]string{},
					GroupIDs: []int64{},
					Scopes:   []sdk.AuthConsumerScope{sdk.AuthConsumerScopeHatchery, sdk.AuthConsumerScopeRunExecution, sdk.AuthConsumerScopeService},
				}

				h.Swarm.API.Token, err = builtin.NewSigninConsumerToken(&c)
				if err != nil {
					sdk.Exit("%v", err)
				}

				startupCfg.Consumers = append(startupCfg.Consumers, cfg)
				h.Swarm.DockerEngines = map[string]swarm.DockerEngineConfiguration{
					"sample-docker-engine": {
						Host: "///var/run/docker.sock",
					},
				}
				privateKey, _ := jws.NewRandomRSAKey()
				privateKeyPEM, _ := jws.ExportPrivateKey(privateKey)
				h.Swarm.RSAPrivateKey = string(privateKeyPEM)
				h.Swarm.Name = "cds-hatchery-swarm-" + namesgenerator.GetRandomNameCDS(0)
			}
			if h.Marathon != nil {
				var cfg = api.StartupConfigService{
					ID:          sdk.UUID(),
					Name:        "hatchery:marathon",
					Description: "Autogenerated configuration for marathon hatchery",
					ServiceType: services.TypeHatchery,
				}

				var c = sdk.AuthConsumer{
					ID:          cfg.ID,
					Name:        cfg.Name,
					Description: cfg.Description,

					Type:     sdk.ConsumerBuiltin,
					Data:     map[string]string{},
					GroupIDs: []int64{},
					Scopes:   []sdk.AuthConsumerScope{sdk.AuthConsumerScopeHatchery, sdk.AuthConsumerScopeRunExecution, sdk.AuthConsumerScopeService},
				}

				conf.Hatchery.Marathon.API.Token, err = builtin.NewSigninConsumerToken(&c)
				if err != nil {
					sdk.Exit("%v", err)
				}

				startupCfg.Consumers = append(startupCfg.Consumers, cfg)
				privateKey, _ := jws.NewRandomRSAKey()
				privateKeyPEM, _ := jws.ExportPrivateKey(privateKey)
				h.Marathon.RSAPrivateKey = string(privateKeyPEM)
				h.Marathon.Name = "cds-hatchery-marathon-" + namesgenerator.GetRandomNameCDS(0)
			}
		}

		if conf.Hooks != nil {
			var cfg = api.StartupConfigService{
				ID:          sdk.UUID(),
				Name:        "hooks",
				Description: "Autogenerated configuration for hooks service",
				ServiceType: services.TypeHooks,
			}

			var c = sdk.AuthConsumer{
				ID:          cfg.ID,
				Name:        cfg.Name,
				Description: cfg.Description,
				Type:        sdk.ConsumerBuiltin,
				Data:        map[string]string{},
				GroupIDs:    []int64{},
				Scopes: []sdk.AuthConsumerScope{
					sdk.AuthConsumerScopeService,
					sdk.AuthConsumerScopeHooks,
					sdk.AuthConsumerScopeProject,
					sdk.AuthConsumerScopeRun},
			}

			conf.Hooks.API.Token, err = builtin.NewSigninConsumerToken(&c)
			if err != nil {
				sdk.Exit("%v", err)
			}

			startupCfg.Consumers = append(startupCfg.Consumers, cfg)
			conf.Hooks.Name = "cds-hooks-" + namesgenerator.GetRandomNameCDS(0)
		}

		if conf.Repositories != nil {
			var cfg = api.StartupConfigService{
				ID:          sdk.UUID(),
				Name:        "repositories",
				Description: "Autogenerated configuration for repositories service",
				ServiceType: services.TypeHooks,
			}

			var c = sdk.AuthConsumer{
				ID:          cfg.ID,
				Name:        cfg.Name,
				Description: cfg.Description,
				Type:        sdk.ConsumerBuiltin,
				Data:        map[string]string{},
				GroupIDs:    []int64{},
				Scopes:      []sdk.AuthConsumerScope{sdk.AuthConsumerScopeService},
			}

			conf.Repositories.API.Token, err = builtin.NewSigninConsumerToken(&c)
			if err != nil {
				sdk.Exit("%v", err)
			}

			startupCfg.Consumers = append(startupCfg.Consumers, cfg)
			conf.Repositories.Name = "cds-repositories-" + namesgenerator.GetRandomNameCDS(0)
		}

		if conf.DatabaseMigrate != nil {
			var cfg = api.StartupConfigService{
				ID:          sdk.UUID(),
				Name:        "migrate",
				Description: "Autogenerated configuration for migrate service",
				ServiceType: services.TypeDBMigrate,
			}

			var c = sdk.AuthConsumer{
				ID:          cfg.ID,
				Name:        cfg.Name,
				Description: cfg.Description,
				Type:        sdk.ConsumerBuiltin,
				Data:        map[string]string{},
				GroupIDs:    []int64{},
				Scopes:      []sdk.AuthConsumerScope{sdk.AuthConsumerScopeService},
			}

			conf.DatabaseMigrate.API.Token, err = builtin.NewSigninConsumerToken(&c)
			if err != nil {
				sdk.Exit("%v", err)
			}

			startupCfg.Consumers = append(startupCfg.Consumers, cfg)
			conf.DatabaseMigrate.Name = "cds-migrate-" + namesgenerator.GetRandomNameCDS(0)
		}

		if conf.VCS != nil {
			var cfg = api.StartupConfigService{
				ID:          sdk.UUID(),
				Name:        "vcs",
				Description: "Autogenerated configuration for vcs service",
				ServiceType: services.TypeVCS,
			}

			var c = sdk.AuthConsumer{
				ID:          cfg.ID,
				Name:        cfg.Name,
				Description: cfg.Description,
				Type:        sdk.ConsumerBuiltin,
				Data:        map[string]string{},
				GroupIDs:    []int64{},
				Scopes:      []sdk.AuthConsumerScope{sdk.AuthConsumerScopeService},
			}

			conf.VCS.API.Token, err = builtin.NewSigninConsumerToken(&c)
			if err != nil {
				sdk.Exit("%v", err)
			}

			startupCfg.Consumers = append(startupCfg.Consumers, cfg)
			conf.VCS.Name = "cds-vcs-" + namesgenerator.GetRandomNameCDS(0)
		}

		if !flagConfigNewAsEnv {
			btes, err := toml.Marshal(*conf)
			if err != nil {
				sdk.Exit("%v", err)
			}
			fmt.Println(string(btes))
		} else {
			m := configToEnvVariables(conf)
			keys := make([]string, 0, len(m))
			for k := range m {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			for _, k := range keys {
				// Print the export command and escape all \n in value (useful for keys)
				fmt.Printf("export %s=\"%s\"\n", k, strings.ReplaceAll(m[k], "\n", "\\n"))
			}
		}

		magicToken, err := authentication.SignJWS(startupCfg, time.Hour)
		if err != nil {
			sdk.Exit("%v", err)
		}

		fmt.Println("# On first login, you will be asked to enter the following token:")
		fmt.Println("# " + magicToken)
	},
}

var configCheckCmd = &cobra.Command{
	Use:   "check",
	Short: "Check CDS configuration file",
	Long:  `$ engine config check <path>`,
	Run: func(cmd *cobra.Command, args []string) {
		if len(args) != 1 {
			cmd.Help()
			sdk.Exit("Wrong usage")
		}

		// Initialize config from given path
		conf := configImport(nil, args[0], "", "", "", "")

		var hasError bool
		if conf.API != nil && conf.API.URL.API != "" {
			fmt.Printf("checking api configuration...\n")
			if err := api.New().CheckConfiguration(*conf.API); err != nil {
				fmt.Printf("api Configuration: %v\n", err)
				hasError = true
			}
		}

		if conf.DatabaseMigrate != nil && conf.DatabaseMigrate.API.HTTP.URL != "" {
			fmt.Printf("checking migrate configuration...\n")
			if err := api.New().CheckConfiguration(*conf.DatabaseMigrate); err != nil {
				fmt.Printf("migrate Configuration: %v\n", err)
				hasError = true
			}
		}

		if conf.Hatchery != nil && conf.Hatchery.Local != nil && conf.Hatchery.Local.API.HTTP.URL != "" {
			fmt.Printf("checking hatchery:local configuration...\n")
			if err := local.New().CheckConfiguration(*conf.Hatchery.Local); err != nil {
				fmt.Printf("hatchery:local Configuration: %v\n", err)
				hasError = true
			}
		}

		if conf.Hatchery != nil && conf.Hatchery.Marathon != nil && conf.Hatchery.Marathon.API.HTTP.URL != "" {
			fmt.Printf("checking hatchery:marathon configuration...\n")
			if err := marathon.New().CheckConfiguration(*conf.Hatchery.Marathon); err != nil {
				fmt.Printf("hatchery:marathon Configuration: %v\n", err)
				hasError = true
			}
		}

		if conf.Hatchery != nil && conf.Hatchery.Openstack != nil && conf.Hatchery.Openstack.API.HTTP.URL != "" {
			fmt.Printf("checking hatchery:openstack configuration...\n")
			if err := openstack.New().CheckConfiguration(*conf.Hatchery.Openstack); err != nil {
				fmt.Printf("hatchery:openstack Configuration: %v\n", err)
				hasError = true
			}
		}

		if conf.Hatchery != nil && conf.Hatchery.Kubernetes != nil && conf.Hatchery.Kubernetes.API.HTTP.URL != "" {
			fmt.Printf("checking hatchery:kubernetes configuration...\n")
			if err := kubernetes.New().CheckConfiguration(*conf.Hatchery.Kubernetes); err != nil {
				fmt.Printf("hatchery:kubernetes Configuration: %v\n", err)
				hasError = true
			}
		}

		if conf.Hatchery != nil && conf.Hatchery.Swarm != nil && conf.Hatchery.Swarm.API.HTTP.URL != "" {
			fmt.Printf("checking hatchery:swarm configuration...\n")
			if err := swarm.New().CheckConfiguration(*conf.Hatchery.Swarm); err != nil {
				fmt.Printf("hatchery:swarm Configuration: %v\n", err)
				hasError = true
			}
		}

		if conf.Hatchery != nil && conf.Hatchery.VSphere != nil && conf.Hatchery.VSphere.API.HTTP.URL != "" {
			fmt.Printf("checking hatchery:vsphere configuration...\n")
			if err := vsphere.New().CheckConfiguration(*conf.Hatchery.VSphere); err != nil {
				fmt.Printf("hatchery:vsphere Configuration: %v\n", err)
				hasError = true
			}
		}

		if conf.VCS != nil && conf.VCS.API.HTTP.URL != "" {
			fmt.Printf("checking vcs configuration...\n")
			if err := vcs.New().CheckConfiguration(*conf.VCS); err != nil {
				fmt.Printf("vcs Configuration: %v\n", err)
				hasError = true
			}
		}

		if conf.Hooks != nil && conf.Hooks.API.HTTP.URL != "" {
			fmt.Printf("checking hooks configuration...\n")
			if err := hooks.New().CheckConfiguration(*conf.Hooks); err != nil {
				fmt.Printf("hooks Configuration: %v\n", err)
				hasError = true
			}
		}

		if !hasError {
			fmt.Println("Configuration file OK")
		}
	},
}
